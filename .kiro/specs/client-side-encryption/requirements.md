# 需求文档

## 简介

本功能为文件上传组件添加端到端加密（E2EE）功能，使用 `age-encryption` 库实现。采用 X25519 公私钥加密方案：

1. **公私钥对在客户端生成**：identity（私钥）用于解密，recipient（公钥）用于加密
2. **公钥可公开存储**：加密时只需公钥，无需输入密码
3. **私钥用密码保护**：私钥使用用户密码加密后存储在服务端
4. **服务端无法解密**：服务端只存储加密后的私钥，永远无法获取原始私钥

**密钥架构说明：**
- 每个用户有一对固定的密钥：identity（私钥）+ recipient（公钥）
- 所有文件都用公钥加密，只有对应的私钥能解密
- 用户密码只是用来保护私钥，修改密码不会影响已加密的文件
- 重设密码后，私钥不变，之前加密的文件仍然可以正常解密

加密和解密过程在 Web Worker 中使用流式处理执行，避免阻塞主线程和占用过多内存。

## 术语表

- **age-encryption**: 一个成熟的 TypeScript 加密库，基于 age 文件加密格式
- **identity（私钥）**: age 格式的私钥字符串，以 `AGE-SECRET-KEY-1` 开头，用于解密
- **recipient（公钥）**: age 格式的公钥字符串，以 `age1` 开头，用于加密
- **加密密码 (Encryption_Password)**: 用户设置的密码，用于保护私钥
- **加密后的私钥 (Encrypted_Identity)**: 使用 age passphrase 模式加密后的私钥
- **端到端加密 (E2EE)**: 只有用户能解密数据，服务端无法获取原始内容
- **恢复密钥 (Recovery_Key)**: 用于在忘记加密密码时恢复私钥的高熵字符串
- **加密 Worker (Encryption_Worker)**: 在 Web Worker 中执行加密操作的后台线程
- **解密 Worker (Decryption_Worker)**: 在 Web Worker 中执行解密操作的后台线程
- **文件上传组件 (File_Uploader)**: 现有的 fileUploader.vue 组件
- **useFileEncryption**: 文件加密 Composable，提供程序化加密功能
- **useFileDecryption**: 文件解密 Composable，提供程序化解密功能

## 需求

### 需求 1：密钥对生成与管理

**用户故事：** 作为用户，我希望系统为我生成安全的加密密钥对，并用我的密码保护私钥，以确保只有我能解密文件。

#### 验收标准

1. 当用户首次启用加密功能时，系统应提示用户设置加密密码
2. 客户端应使用 age-encryption 库的 `generateIdentity()` 生成密钥对
3. 客户端应使用 age passphrase 模式，用用户密码加密 identity（私钥）
4. 加密后的私钥（encryptedIdentity）和公钥（recipient）应存储在服务端
5. 服务端永远无法获取原始私钥，因为只存储加密后的版本
6. 公钥（recipient）可以明文存储，因为公钥本身不需要保密
7. 当用户需要解密文件时，系统应提示输入加密密码
8. 客户端应使用密码解密获取原始 identity（私钥）
9. 如果密码错误，age-encryption 会抛出解密错误，系统应提示"加密密码错误"
10. 解密后的私钥应仅存储在内存中，不持久化到本地存储
11. 当用户登出或关闭浏览器时，内存中的私钥应被清除

### 需求 1.1：加密密码管理

**用户故事：** 作为用户，我希望能够管理我的加密密码，包括修改密码和在设备上记住密码。

#### 验收标准

1. 用户应能够修改加密密码
2. 修改密码时，客户端应使用旧密码解密私钥，再用新密码重新加密
3. 修改密码后，客户端应更新服务端的加密后私钥
4. 用户可选择"在此设备上记住加密密码"
5. 如果选择记住密码，客户端应将密码安全存储在设备上（IndexedDB，使用设备指纹加密）
6. 记住密码后，下次访问时应自动解密私钥，无需再次输入
7. 用户应能够清除设备上记住的密码
8. 如果用户忘记加密密码且未设置恢复密钥，加密文件将无法恢复

### 需求 1.2：密钥恢复机制（可选）

**用户故事：** 作为用户，我希望有一种安全的方式在忘记加密密码时恢复我的私钥，以避免永久丢失加密文件。

#### 验收标准

1. 用户可选择生成恢复密钥（Recovery Key），这是一个随机生成的高熵字符串
2. 客户端应使用恢复密钥（作为 passphrase）加密私钥，生成恢复用的加密私钥
3. 恢复用的加密私钥应存储在服务端
4. 用户应被提示安全保存恢复密钥（如打印或存储在密码管理器中）
5. 当用户忘记加密密码时，可使用恢复密钥解密私钥
6. 使用恢复密钥后，用户应被要求设置新的加密密码并重新加密私钥
7. 恢复密钥应只能使用一次，使用后应生成新的恢复密钥
8. 重设密码后，私钥本身不变，因此之前加密的所有文件仍然可以正常解密
9. 如果用户既忘记加密密码又丢失恢复密钥，加密文件将永久无法恢复

### 需求 2：加密选项控制

**用户故事：** 作为用户，我希望在上传文件时可以选择是否启用加密，以便根据文件敏感程度决定是否加密。

#### 验收标准

1. 当文件上传组件启用加密功能时，组件应显示加密开关
2. 当用户开启加密开关时，组件应提示文件将在上传前加密
3. 当加密为可选（默认）时，组件应允许在关闭加密开关时进行未加密上传
4. 文件上传组件应支持通过 prop 设置默认加密状态
5. 如果用户未设置加密密钥，加密开关应禁用并显示"请先设置加密密码"提示
6. 加密时只需要公钥，无需输入密码（公钥已存储在服务端）

### 需求 3：文件加密处理

**用户故事：** 作为用户，我希望文件在后台加密而不会冻结浏览器或占用过多内存，以便在加密进行时可以继续使用应用程序。

#### 验收标准

1. 当选择文件进行加密上传时，加密 Worker 应在 Web Worker 线程中执行加密
2. 加密 Worker 应使用 age-encryption 的 `Encrypter` 类进行加密
3. 加密时应使用 `e.addRecipient(recipient)` 添加用户的公钥
4. 对于大文件，应使用 `e.encrypt(file.stream())` 进行流式加密
5. 加密进行时，文件上传组件应向用户显示加密进度
6. 如果加密失败，文件上传组件应显示错误消息且不继续上传
7. 加密后的文件格式为 age 标准格式，可被任何 age 兼容工具解密

### 需求 4：加密文件上传

**用户故事：** 作为用户，我希望加密文件能无缝上传到 OSS，使加密过程对存储系统透明。

#### 验收标准

1. 加密完成后，文件上传组件应将加密后的 Blob 上传到 OSS
2. 文件上传组件应修改文件扩展名以标识加密（例如添加 .age 后缀）
3. 文件上传组件应在 OSS 回调变量中包含加密标识（`encrypted: true`）
4. 上传加密文件时，文件上传组件应报告组合进度（加密 + 上传）
5. 文件上传组件应在文件记录中存储加密标识以便后续识别
6. 数据库中存储的 mimeType 应为原始文件的 MIME 类型
7. 数据库中应存储原始文件名（不含 .age 后缀）
8. 内存使用应控制在合理范围内，使用流式处理避免加载整个文件

### 需求 5：加密进度反馈

**用户故事：** 作为用户，我希望看到加密和上传的进度，以便知道整个过程需要多长时间。

#### 验收标准

1. 加密开始时，文件上传组件应显示"加密中..."状态
2. 加密进行时，文件上传组件应显示加密百分比进度
3. 加密完成并开始上传时，文件上传组件应显示"上传中..."状态
4. 文件上传组件应显示反映加密和上传两个阶段的组合进度条
5. 加密和上传都完成时，文件上传组件应显示成功状态

### 需求 6：批量文件加密上传

**用户故事：** 作为用户，我希望一次加密并上传多个文件，以便高效地保护和存储多个文件。

#### 验收标准

1. 当启用加密选择多个文件时，加密 Worker 应依次加密文件
2. 加密多个文件时，文件上传组件应显示每个文件的单独进度
3. 批量模式下文件加密失败时，文件上传组件应继续处理剩余文件并报告失败
4. 批量上传中的所有文件应使用相同的公钥加密

### 需求 7：文件解密

**用户故事：** 作为开发者，我希望有一套解密工具方法，以便在各种场景中解密文件。

#### 验收标准

1. 客户端加密模块应提供 `decryptFile` 方法用于解密文件数据
2. `decryptFile` 方法应接受加密的 ArrayBuffer、Blob 或 URL 作为输入
3. 解密前应检查用户私钥是否已解锁（在内存中）
4. 如果私钥未解锁，应提示用户输入加密密码
5. 解密应使用 age-encryption 的 `Decrypter` 类，通过 `d.addIdentity(identity)` 添加私钥
6. 对于大文件，应使用流式解密
7. 如果私钥不匹配（文件不是用对应公钥加密的），应抛出明确错误
8. 解密后的数据应仅存在于内存中，不持久化
9. 客户端加密模块应提供 `decryptToBlob` 方法，返回带有正确 MIME 类型的 Blob
10. 客户端加密模块应提供 `decryptToObjectURL` 方法，返回可直接用于展示的 Object URL
11. 调用方应负责在使用完毕后释放 Object URL

### 需求 8：解密进度与错误处理

**用户故事：** 作为开发者，我希望解密工具提供进度回调和清晰的错误类型，以便在 UI 中展示适当的状态。

#### 验收标准

1. 解密方法应支持可选的进度回调函数
2. 进度回调应报告解密百分比（0-100）
3. 解密成功时，方法应返回解密后的数据
4. 如果因私钥未解锁导致解密失败，方法应抛出 `IdentityNotUnlockedError`
5. 如果因私钥不匹配导致解密失败，方法应抛出 `IdentityMismatchError`
6. 如果因文件损坏导致解密失败，方法应抛出 `FileCorruptedError`
7. 如果因文件格式无效（非 age 格式）导致解密失败，方法应抛出 `InvalidAgeFileError`
8. 所有错误类型应包含用户友好的错误消息

### 需求 9：加密解密 Composable

**用户故事：** 作为开发者，我希望有响应式的加密解密 composable，以便在 Vue 组件中方便地使用加密解密功能。

#### 验收标准

1. 客户端加密模块应提供 `useAgeCrypto` composable 用于密钥管理
2. `useAgeCrypto` 应提供 `generateKeyPair()` 方法生成新密钥对
3. `useAgeCrypto` 应提供 `unlockIdentity(password)` 方法解锁私钥
4. `useAgeCrypto` 应提供 `isUnlocked` 响应式状态表示私钥是否已解锁
5. 客户端加密模块应提供 `useFileEncryption` composable 用于响应式加密
6. `useFileEncryption` 应返回响应式的加密进度、状态和加密后的数据
7. 客户端加密模块应提供 `useFileDecryption` composable 用于响应式解密
8. `useFileDecryption` 应返回响应式的解密进度、状态、Object URL 和错误信息
9. 所有 composable 都应支持取消操作
10. `useFileDecryption` 应在组件卸载时自动释放 Object URL

### 需求 10：加密配置与类型定义

**用户故事：** 作为开发者，我希望有清晰的类型定义和配置选项，以便正确集成加密功能。

#### 验收标准

1. 客户端加密模块应导出所有加密相关类型的 TypeScript 接口
2. 文件上传组件应接受 `enableEncryption` prop 来显示/隐藏加密选项
3. 文件上传组件应接受 `defaultEncrypted` prop 来设置加密开关的初始状态
4. 加密文件使用标准 age 格式，无需自定义元数据格式
5. 数据库应存储：原始文件名、原始 MIME 类型、加密标识、OSS 路径
6. 加密相关的 API 应有完整的 TypeScript 类型定义
