# 使用指南

本文档介绍如何在项目中使用文件加密功能。

## 首次设置加密

### 1. 生成密钥对

```typescript
const { generateKeyPair, encryptIdentity } = useAgeCrypto()
const encryptionStore = useEncryptionStore()

// 生成新的密钥对
const { identity, recipient } = await generateKeyPair()

// 使用用户密码加密私钥
const encryptedIdentity = await encryptIdentity(identity, userPassword)

// 保存到服务器
await encryptionStore.saveConfig(recipient, encryptedIdentity)
```

### 2. 使用设置对话框组件

项目提供了现成的设置对话框组件：

```vue
<template>
    <EncryptionSetupDialog 
        v-model:open="showSetupDialog" 
        @success="handleSetupSuccess" 
    />
</template>

<script setup>
const showSetupDialog = ref(false)

const handleSetupSuccess = () => {
    toast.success('加密设置完成')
}
</script>
```

## 解锁私钥

### 手动解锁

```typescript
const { unlockIdentity, isUnlocked } = useAgeCrypto()
const encryptionStore = useEncryptionStore()

// 获取加密配置
await encryptionStore.fetchConfig()

// 解锁私钥
try {
    await unlockIdentity(
        encryptionStore.config.encryptedIdentity,
        userPassword
    )
    console.log('解锁成功:', isUnlocked.value) // true
} catch (err) {
    if (err.name === 'WrongPasswordError') {
        toast.error('密码错误')
    }
}
```

### 使用解锁对话框组件

```vue
<template>
    <EncryptionPasswordDialog 
        v-model:open="showPasswordDialog" 
        @success="handleUnlockSuccess" 
    />
</template>
```

### 自动恢复

页面刷新后，私钥会自动从 IndexedDB 恢复：

```typescript
const { restoreIdentity, isUnlocked } = useAgeCrypto()

onMounted(async () => {
    // 尝试恢复私钥状态
    const restored = await restoreIdentity()
    
    if (restored) {
        console.log('私钥已自动恢复')
    } else {
        console.log('需要用户输入密码解锁')
    }
})
```

## 加密上传文件

### 使用 FileUploader 组件

最简单的方式是使用内置的文件上传组件：

```vue
<template>
    <GeneralFileUploader
        :source="FileSource.FILE"
        :multiple="true"
        :autoUpload="true"
        :enableEncryption="true"
        :defaultEncrypted="true"
        :onSuccess="handleUploadSuccess"
        :onError="handleUploadError"
    />
</template>

<script setup>
const handleUploadSuccess = (files) => {
    console.log('上传成功:', files)
}

const handleUploadError = (error) => {
    console.error('上传失败:', error)
}
</script>
```

**Props 说明**：
- `enableEncryption` - 启用加密功能（显示加密开关）
- `defaultEncrypted` - 默认开启加密

### 手动加密上传

```typescript
const { encryptFile } = useAgeCrypto()
const encryptionStore = useEncryptionStore()
const fileStore = useFileStore()

// 1. 确保已获取加密配置
await encryptionStore.fetchConfig()

// 2. 加密文件
const encryptedBlob = await encryptFile(
    file,
    encryptionStore.config.recipient,
    (progress) => console.log(`加密进度: ${progress}%`)
)

// 3. 获取上传签名（标记为加密文件）
const signature = await fileStore.getPresignedUrl({
    source: 'file',
    originalFileName: file.name,
    fileSize: encryptedBlob.size,
    mimeType: file.type,
    encrypted: true  // 标记为加密文件
})

// 4. 上传加密后的文件
await uploadToOSS(encryptedBlob, signature)
```

## 解密预览文件

### 自动判断并解密

```typescript
const { fetchAndDecryptToObjectURL, isEncryptedUrl } = useAgeCrypto()

// 自动判断是否需要解密
const previewUrl = await fetchAndDecryptToObjectURL(
    fileUrl,
    'image/jpeg',
    ({ stage, progress }) => {
        switch (stage) {
            case 'check':
                loadingText.value = '检查加密状态...'
                break
            case 'download':
                loadingText.value = '下载文件...'
                break
            case 'decrypt':
                loadingText.value = '解密中...'
                break
        }
    }
)

// 用于图片展示
imageElement.src = previewUrl
```

### 手动解密

```typescript
const { decryptToObjectURL, isUnlocked } = useAgeCrypto()

// 1. 检查私钥状态
if (!isUnlocked.value) {
    throw new Error('请先解锁私钥')
}

// 2. 下载加密文件
const response = await fetch(encryptedFileUrl)
const encryptedBlob = await response.blob()

// 3. 解密
const objectUrl = await decryptToObjectURL(
    encryptedBlob,
    'image/jpeg',
    (progress) => console.log(`解密进度: ${progress}%`)
)

// 4. 使用
imageElement.src = objectUrl

// 5. 清理（重要！）
onUnmounted(() => {
    URL.revokeObjectURL(objectUrl)
})
```

## 解密下载文件

```typescript
const { fetchAndDecryptToObjectURL, isEncryptedUrl } = useAgeCrypto()

const downloadFile = async (file) => {
    const fileUrl = file.url
    
    if (isEncryptedUrl(fileUrl)) {
        // 加密文件：先解密再下载
        const decryptedUrl = await fetchAndDecryptToObjectURL(
            fileUrl,
            file.fileType
        )
        
        // 创建下载链接
        const link = document.createElement('a')
        link.href = decryptedUrl
        // 移除 .age 后缀
        link.download = file.fileName.replace(/\.age$/, '')
        link.click()
        
        // 清理
        URL.revokeObjectURL(decryptedUrl)
    } else {
        // 非加密文件：直接下载
        const link = document.createElement('a')
        link.href = fileUrl
        link.download = file.fileName
        link.click()
    }
}
```

## 修改加密密码

```typescript
const { decryptIdentity, encryptIdentity, lockIdentity } = useAgeCrypto()
const encryptionStore = useEncryptionStore()

// 1. 用旧密码解密私钥
const identity = await decryptIdentity(
    encryptionStore.config.encryptedIdentity,
    oldPassword
)

// 2. 用新密码重新加密
const newEncryptedIdentity = await encryptIdentity(identity, newPassword)

// 3. 更新服务器配置
await encryptionStore.updateConfig(newEncryptedIdentity)

// 4. 锁定私钥（需要用新密码重新解锁）
await lockIdentity()
```

## 使用恢复密钥

### 生成恢复密钥

```typescript
const { decryptIdentity, encryptIdentity } = useAgeCrypto()
const encryptionStore = useEncryptionStore()

// 1. 用当前密码解密私钥
const identity = await decryptIdentity(
    encryptionStore.config.encryptedIdentity,
    currentPassword
)

// 2. 生成随机恢复密钥
const recoveryKey = generateRandomKey(32) // 生成 32 字符的随机密钥

// 3. 用恢复密钥加密私钥
const encryptedRecoveryKey = await encryptIdentity(identity, recoveryKey)

// 4. 保存到服务器
await encryptionStore.updateConfig(
    encryptionStore.config.encryptedIdentity,
    encryptedRecoveryKey
)

// 5. 显示恢复密钥给用户（只显示一次！）
showRecoveryKeyToUser(recoveryKey)
```

### 使用恢复密钥重置密码

```typescript
const { decryptIdentity, encryptIdentity, unlockIdentity } = useAgeCrypto()
const encryptionStore = useEncryptionStore()

// 1. 用恢复密钥解密私钥
const identity = await decryptIdentity(
    encryptionStore.config.encryptedRecoveryKey,
    recoveryKey
)

// 2. 用新密码加密私钥
const newEncryptedIdentity = await encryptIdentity(identity, newPassword)

// 3. 更新服务器配置
await encryptionStore.resetWithRecoveryKey(newEncryptedIdentity)

// 4. 解锁私钥
await unlockIdentity(newEncryptedIdentity, newPassword)
```

## 错误处理

```typescript
import {
    IdentityNotUnlockedError,
    IdentityMismatchError,
    FileCorruptedError,
    InvalidAgeFileError,
    WrongPasswordError,
} from '~~/shared/types/encryption'

try {
    await decryptFile(encryptedData)
} catch (err) {
    if (err instanceof IdentityNotUnlockedError) {
        // 提示用户解锁私钥
        showUnlockDialog()
    } else if (err instanceof IdentityMismatchError) {
        // 私钥不匹配，文件可能是用其他密钥加密的
        toast.error('无法解密此文件，密钥不匹配')
    } else if (err instanceof InvalidAgeFileError) {
        // 文件格式无效
        toast.error('文件格式无效')
    } else if (err instanceof FileCorruptedError) {
        // 文件损坏
        toast.error('文件已损坏')
    } else if (err instanceof WrongPasswordError) {
        // 密码错误
        toast.error('密码错误，请重试')
    } else {
        // 其他错误
        toast.error('操作失败: ' + err.message)
    }
}
```

## 最佳实践

### 1. 及时清理 Object URL

```typescript
const objectUrls = ref<string[]>([])

const loadPreview = async (file) => {
    const url = await decryptToObjectURL(data, mimeType)
    objectUrls.value.push(url)
    return url
}

onUnmounted(() => {
    // 清理所有 Object URL
    objectUrls.value.forEach(url => URL.revokeObjectURL(url))
})
```

### 2. 显示加载状态

```typescript
const loading = ref(false)
const loadingText = ref('')

const loadFile = async () => {
    loading.value = true
    
    try {
        await fetchAndDecryptToObjectURL(url, mimeType, ({ stage }) => {
            switch (stage) {
                case 'check':
                    loadingText.value = '检查加密状态...'
                    break
                case 'download':
                    loadingText.value = '下载文件...'
                    break
                case 'decrypt':
                    loadingText.value = '解密中...'
                    break
            }
        })
    } finally {
        loading.value = false
    }
}
```

### 3. 检查加密配置

```typescript
const encryptionStore = useEncryptionStore()

// 在需要加密功能的页面，先检查配置
onMounted(async () => {
    await encryptionStore.fetchConfig()
    
    if (!encryptionStore.hasEncryption) {
        // 提示用户设置加密
        toast.info('请先设置加密密码')
    }
})
```

### 4. 处理用户切换

```typescript
// 用户登出时清理加密状态
const logout = async () => {
    const encryptionStore = useEncryptionStore()
    await encryptionStore.clearConfig()
    
    // 其他登出逻辑...
}
```
