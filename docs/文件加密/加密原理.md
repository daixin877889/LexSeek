# 加密原理

本文档详细介绍文件加密模块的加密算法、密钥管理和安全机制。

## 加密算法

### age 加密

项目使用 [age-encryption](https://github.com/FiloSottile/age) 库实现文件加密，这是一个现代、安全的加密工具。

**核心特性**：
- 基于 X25519 椭圆曲线的非对称加密
- 使用 ChaCha20-Poly1305 进行对称加密
- 简单的密钥格式，易于管理

**密钥格式**：
```
私钥 (Identity): AGE-SECRET-KEY-1QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ
公钥 (Recipient): age1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
```

### 加密流程

```
原始文件 → age 加密(公钥) → 加密文件(.age) → 上传到 OSS
```

1. 用户选择文件并启用加密
2. 使用用户的公钥（recipient）加密文件
3. 加密后的文件扩展名添加 `.age` 后缀
4. 上传加密后的文件到 OSS

### 解密流程

```
下载加密文件 → age 解密(私钥) → 原始文件
```

1. 从 OSS 下载加密文件
2. 使用用户的私钥（identity）解密
3. 返回原始文件内容

## 密钥管理

### 密钥层级

项目采用三层密钥管理：

```
┌─────────────────────────────────────────────────────────┐
│                    用户密码                              │
│                      ↓                                  │
│              age 密码加密                                │
│                      ↓                                  │
│  ┌─────────────────────────────────────────────────┐   │
│  │           加密后的私钥                            │   │
│  │     (存储在服务器数据库)                          │   │
│  └─────────────────────────────────────────────────┘   │
│                      ↓                                  │
│              用户输入密码解密                            │
│                      ↓                                  │
│  ┌─────────────────────────────────────────────────┐   │
│  │           原始私钥                                │   │
│  │     (存储在浏览器 IndexedDB)                      │   │
│  └─────────────────────────────────────────────────┘   │
│                      ↓                                  │
│              用于文件解密                               │
└─────────────────────────────────────────────────────────┘
```

### 私钥加密存储

私钥使用 age 的密码加密功能进行保护：

```typescript
// 加密私钥
const encryptIdentity = async (identity: string, password: string): Promise<string> => {
    const { Encrypter } = await import('age-encryption')
    const e = new Encrypter()
    e.setPassphrase(password)  // 使用用户密码
    const encrypted = await e.encrypt(new TextEncoder().encode(identity))
    return btoa(String.fromCharCode(...encrypted))  // Base64 编码
}
```

### IndexedDB 本地存储

解锁后的私钥存储在 IndexedDB 中，使用设备指纹派生的密钥进行二次加密：

```typescript
// 设备指纹生成
const getDeviceFingerprint = (): string => {
    const parts = [
        navigator.userAgent,
        navigator.language,
        screen.width.toString(),
        screen.height.toString(),
        new Date().getTimezoneOffset().toString(),
    ]
    return parts.join('|')
}

// 派生加密密钥
const deriveKey = async (): Promise<CryptoKey> => {
    const fingerprint = getDeviceFingerprint()
    // 使用 PBKDF2 派生 AES-256-GCM 密钥
    // 100000 次迭代，SHA-256 哈希
}
```

**存储键格式**：`identity-user-{userId}`

每个用户的私钥使用独立的键存储，避免多用户登录时混淆。

## 安全机制

### 端到端加密

```
┌──────────┐    加密文件    ┌──────────┐    加密文件    ┌──────────┐
│  客户端   │ ────────────→ │  服务器   │ ────────────→ │   OSS    │
│          │               │          │               │          │
│ 明文文件  │               │ 无法解密  │               │ 无法解密  │
│ 私钥解密  │               │          │               │          │
└──────────┘               └──────────┘               └──────────┘
```

- 文件在客户端加密后上传
- 服务器只存储加密后的私钥，无法获取原始私钥
- OSS 存储的是加密文件，无法查看内容

### Web Worker 隔离

加密/解密操作在 Web Worker 中执行：

```typescript
// 主线程
const encrypted = await encryptFile(file, recipient)

// Worker 线程执行实际加密
self.onmessage = async (event) => {
    const { type, data, recipient } = event.data
    if (type === 'encrypt') {
        const e = new Encrypter()
        e.addRecipient(recipient)
        const encrypted = await e.encrypt(new Uint8Array(data))
        // 使用 Transferable 传输，避免复制
        self.postMessage({ type: 'success', data: encrypted.buffer }, [encrypted.buffer])
    }
}
```

**优势**：
- 不阻塞主线程，保持 UI 响应
- 隔离加密操作，提高安全性
- 使用 Transferable 传输大文件，避免内存复制

### 会话安全

IndexedDB 中的私钥使用 AES-256-GCM 加密：

```typescript
const encryptForStorage = async (data: string): Promise<string> => {
    const key = await deriveKey()  // 从设备指纹派生
    const iv = crypto.getRandomValues(new Uint8Array(12))  // 随机 IV
    
    const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv },
        key,
        encoder.encode(data)
    )
    
    // IV + 密文合并后 Base64 编码
    const combined = new Uint8Array(iv.length + encrypted.byteLength)
    combined.set(iv)
    combined.set(new Uint8Array(encrypted), iv.length)
    return btoa(String.fromCharCode(...combined))
}
```

**安全特性**：
- 每次存储使用随机 IV
- 密钥绑定设备指纹，换设备需重新解锁
- 用户登出时自动清除

## 恢复密钥

### 工作原理

恢复密钥是一个随机生成的高熵密码，用于在忘记主密码时恢复私钥：

```
┌─────────────────────────────────────────────────────────┐
│                    原始私钥                              │
│                    ↓     ↓                              │
│         ┌─────────┴─────┴─────────┐                    │
│         ↓                         ↓                    │
│   用户密码加密                恢复密钥加密               │
│         ↓                         ↓                    │
│   encryptedIdentity      encryptedRecoveryKey          │
│   (存储在服务器)           (存储在服务器)                │
└─────────────────────────────────────────────────────────┘
```

### 恢复流程

1. 用户输入恢复密钥
2. 使用恢复密钥解密 `encryptedRecoveryKey` 获取原始私钥
3. 用户设置新密码
4. 使用新密码重新加密私钥
5. 更新服务器上的 `encryptedIdentity`

## 文件识别

加密文件通过 URL 路径识别：

```typescript
const isEncryptedUrl = (url: string): boolean => {
    try {
        const urlObj = new URL(url)
        return urlObj.pathname.endsWith('.age')
    } catch {
        return false
    }
}
```

**命名规则**：
- 原始文件：`photo.jpg`
- 加密文件：`photo.jpg.age`

下载时自动移除 `.age` 后缀，恢复原始文件名。
