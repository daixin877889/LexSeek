
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `membershipBenefits` model and its related types.
 *
 * üü¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums.js"
import type * as Prisma from "../internal/prismaNamespace.js"

/**
 * Model membershipBenefits
 * ‰ºöÂëòÊùÉÁõäÂÖ≥ËÅîË°®
 */
export type membershipBenefitsModel = runtime.Types.Result.DefaultSelection<Prisma.$membershipBenefitsPayload>

export type AggregateMembershipBenefits = {
  _count: MembershipBenefitsCountAggregateOutputType | null
  _avg: MembershipBenefitsAvgAggregateOutputType | null
  _sum: MembershipBenefitsSumAggregateOutputType | null
  _min: MembershipBenefitsMinAggregateOutputType | null
  _max: MembershipBenefitsMaxAggregateOutputType | null
}

export type MembershipBenefitsAvgAggregateOutputType = {
  id: number | null
  levelId: number | null
  benefitId: number | null
  benefitValue: number | null
}

export type MembershipBenefitsSumAggregateOutputType = {
  id: number | null
  levelId: number | null
  benefitId: number | null
  benefitValue: bigint | null
}

export type MembershipBenefitsMinAggregateOutputType = {
  id: number | null
  levelId: number | null
  benefitId: number | null
  benefitValue: bigint | null
  createdAt: Date | null
  updatedAt: Date | null
  deletedAt: Date | null
}

export type MembershipBenefitsMaxAggregateOutputType = {
  id: number | null
  levelId: number | null
  benefitId: number | null
  benefitValue: bigint | null
  createdAt: Date | null
  updatedAt: Date | null
  deletedAt: Date | null
}

export type MembershipBenefitsCountAggregateOutputType = {
  id: number
  levelId: number
  benefitId: number
  benefitValue: number
  createdAt: number
  updatedAt: number
  deletedAt: number
  _all: number
}


export type MembershipBenefitsAvgAggregateInputType = {
  id?: true
  levelId?: true
  benefitId?: true
  benefitValue?: true
}

export type MembershipBenefitsSumAggregateInputType = {
  id?: true
  levelId?: true
  benefitId?: true
  benefitValue?: true
}

export type MembershipBenefitsMinAggregateInputType = {
  id?: true
  levelId?: true
  benefitId?: true
  benefitValue?: true
  createdAt?: true
  updatedAt?: true
  deletedAt?: true
}

export type MembershipBenefitsMaxAggregateInputType = {
  id?: true
  levelId?: true
  benefitId?: true
  benefitValue?: true
  createdAt?: true
  updatedAt?: true
  deletedAt?: true
}

export type MembershipBenefitsCountAggregateInputType = {
  id?: true
  levelId?: true
  benefitId?: true
  benefitValue?: true
  createdAt?: true
  updatedAt?: true
  deletedAt?: true
  _all?: true
}

export type MembershipBenefitsAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which membershipBenefits to aggregate.
   */
  where?: Prisma.membershipBenefitsWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of membershipBenefits to fetch.
   */
  orderBy?: Prisma.membershipBenefitsOrderByWithRelationInput | Prisma.membershipBenefitsOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.membershipBenefitsWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `¬±n` membershipBenefits from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` membershipBenefits.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned membershipBenefits
  **/
  _count?: true | MembershipBenefitsCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: MembershipBenefitsAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: MembershipBenefitsSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: MembershipBenefitsMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: MembershipBenefitsMaxAggregateInputType
}

export type GetMembershipBenefitsAggregateType<T extends MembershipBenefitsAggregateArgs> = {
      [P in keyof T & keyof AggregateMembershipBenefits]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateMembershipBenefits[P]>
    : Prisma.GetScalarType<T[P], AggregateMembershipBenefits[P]>
}




export type membershipBenefitsGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.membershipBenefitsWhereInput
  orderBy?: Prisma.membershipBenefitsOrderByWithAggregationInput | Prisma.membershipBenefitsOrderByWithAggregationInput[]
  by: Prisma.MembershipBenefitsScalarFieldEnum[] | Prisma.MembershipBenefitsScalarFieldEnum
  having?: Prisma.membershipBenefitsScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: MembershipBenefitsCountAggregateInputType | true
  _avg?: MembershipBenefitsAvgAggregateInputType
  _sum?: MembershipBenefitsSumAggregateInputType
  _min?: MembershipBenefitsMinAggregateInputType
  _max?: MembershipBenefitsMaxAggregateInputType
}

export type MembershipBenefitsGroupByOutputType = {
  id: number
  levelId: number
  benefitId: number
  benefitValue: bigint
  createdAt: Date
  updatedAt: Date
  deletedAt: Date | null
  _count: MembershipBenefitsCountAggregateOutputType | null
  _avg: MembershipBenefitsAvgAggregateOutputType | null
  _sum: MembershipBenefitsSumAggregateOutputType | null
  _min: MembershipBenefitsMinAggregateOutputType | null
  _max: MembershipBenefitsMaxAggregateOutputType | null
}

type GetMembershipBenefitsGroupByPayload<T extends membershipBenefitsGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<MembershipBenefitsGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof MembershipBenefitsGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], MembershipBenefitsGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], MembershipBenefitsGroupByOutputType[P]>
      }
    >
  >



export type membershipBenefitsWhereInput = {
  AND?: Prisma.membershipBenefitsWhereInput | Prisma.membershipBenefitsWhereInput[]
  OR?: Prisma.membershipBenefitsWhereInput[]
  NOT?: Prisma.membershipBenefitsWhereInput | Prisma.membershipBenefitsWhereInput[]
  id?: Prisma.IntFilter<"membershipBenefits"> | number
  levelId?: Prisma.IntFilter<"membershipBenefits"> | number
  benefitId?: Prisma.IntFilter<"membershipBenefits"> | number
  benefitValue?: Prisma.BigIntFilter<"membershipBenefits"> | bigint | number
  createdAt?: Prisma.DateTimeFilter<"membershipBenefits"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"membershipBenefits"> | Date | string
  deletedAt?: Prisma.DateTimeNullableFilter<"membershipBenefits"> | Date | string | null
  level?: Prisma.XOR<Prisma.MembershipLevelsScalarRelationFilter, Prisma.membershipLevelsWhereInput>
  benefit?: Prisma.XOR<Prisma.BenefitsScalarRelationFilter, Prisma.benefitsWhereInput>
}

export type membershipBenefitsOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  levelId?: Prisma.SortOrder
  benefitId?: Prisma.SortOrder
  benefitValue?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  deletedAt?: Prisma.SortOrderInput | Prisma.SortOrder
  level?: Prisma.membershipLevelsOrderByWithRelationInput
  benefit?: Prisma.benefitsOrderByWithRelationInput
}

export type membershipBenefitsWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  levelId_benefitId?: Prisma.membershipBenefitsLevelIdBenefitIdCompoundUniqueInput
  AND?: Prisma.membershipBenefitsWhereInput | Prisma.membershipBenefitsWhereInput[]
  OR?: Prisma.membershipBenefitsWhereInput[]
  NOT?: Prisma.membershipBenefitsWhereInput | Prisma.membershipBenefitsWhereInput[]
  levelId?: Prisma.IntFilter<"membershipBenefits"> | number
  benefitId?: Prisma.IntFilter<"membershipBenefits"> | number
  benefitValue?: Prisma.BigIntFilter<"membershipBenefits"> | bigint | number
  createdAt?: Prisma.DateTimeFilter<"membershipBenefits"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"membershipBenefits"> | Date | string
  deletedAt?: Prisma.DateTimeNullableFilter<"membershipBenefits"> | Date | string | null
  level?: Prisma.XOR<Prisma.MembershipLevelsScalarRelationFilter, Prisma.membershipLevelsWhereInput>
  benefit?: Prisma.XOR<Prisma.BenefitsScalarRelationFilter, Prisma.benefitsWhereInput>
}, "id" | "levelId_benefitId">

export type membershipBenefitsOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  levelId?: Prisma.SortOrder
  benefitId?: Prisma.SortOrder
  benefitValue?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  deletedAt?: Prisma.SortOrderInput | Prisma.SortOrder
  _count?: Prisma.membershipBenefitsCountOrderByAggregateInput
  _avg?: Prisma.membershipBenefitsAvgOrderByAggregateInput
  _max?: Prisma.membershipBenefitsMaxOrderByAggregateInput
  _min?: Prisma.membershipBenefitsMinOrderByAggregateInput
  _sum?: Prisma.membershipBenefitsSumOrderByAggregateInput
}

export type membershipBenefitsScalarWhereWithAggregatesInput = {
  AND?: Prisma.membershipBenefitsScalarWhereWithAggregatesInput | Prisma.membershipBenefitsScalarWhereWithAggregatesInput[]
  OR?: Prisma.membershipBenefitsScalarWhereWithAggregatesInput[]
  NOT?: Prisma.membershipBenefitsScalarWhereWithAggregatesInput | Prisma.membershipBenefitsScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"membershipBenefits"> | number
  levelId?: Prisma.IntWithAggregatesFilter<"membershipBenefits"> | number
  benefitId?: Prisma.IntWithAggregatesFilter<"membershipBenefits"> | number
  benefitValue?: Prisma.BigIntWithAggregatesFilter<"membershipBenefits"> | bigint | number
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"membershipBenefits"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"membershipBenefits"> | Date | string
  deletedAt?: Prisma.DateTimeNullableWithAggregatesFilter<"membershipBenefits"> | Date | string | null
}

export type membershipBenefitsCreateInput = {
  benefitValue: bigint | number
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  level: Prisma.membershipLevelsCreateNestedOneWithoutMembershipBenefitsInput
  benefit: Prisma.benefitsCreateNestedOneWithoutMembershipBenefitsInput
}

export type membershipBenefitsUncheckedCreateInput = {
  id?: number
  levelId: number
  benefitId: number
  benefitValue: bigint | number
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
}

export type membershipBenefitsUpdateInput = {
  benefitValue?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  deletedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  level?: Prisma.membershipLevelsUpdateOneRequiredWithoutMembershipBenefitsNestedInput
  benefit?: Prisma.benefitsUpdateOneRequiredWithoutMembershipBenefitsNestedInput
}

export type membershipBenefitsUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  levelId?: Prisma.IntFieldUpdateOperationsInput | number
  benefitId?: Prisma.IntFieldUpdateOperationsInput | number
  benefitValue?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  deletedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type membershipBenefitsCreateManyInput = {
  id?: number
  levelId: number
  benefitId: number
  benefitValue: bigint | number
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
}

export type membershipBenefitsUpdateManyMutationInput = {
  benefitValue?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  deletedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type membershipBenefitsUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  levelId?: Prisma.IntFieldUpdateOperationsInput | number
  benefitId?: Prisma.IntFieldUpdateOperationsInput | number
  benefitValue?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  deletedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type MembershipBenefitsListRelationFilter = {
  every?: Prisma.membershipBenefitsWhereInput
  some?: Prisma.membershipBenefitsWhereInput
  none?: Prisma.membershipBenefitsWhereInput
}

export type membershipBenefitsOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type membershipBenefitsLevelIdBenefitIdCompoundUniqueInput = {
  levelId: number
  benefitId: number
}

export type membershipBenefitsCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  levelId?: Prisma.SortOrder
  benefitId?: Prisma.SortOrder
  benefitValue?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  deletedAt?: Prisma.SortOrder
}

export type membershipBenefitsAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
  levelId?: Prisma.SortOrder
  benefitId?: Prisma.SortOrder
  benefitValue?: Prisma.SortOrder
}

export type membershipBenefitsMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  levelId?: Prisma.SortOrder
  benefitId?: Prisma.SortOrder
  benefitValue?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  deletedAt?: Prisma.SortOrder
}

export type membershipBenefitsMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  levelId?: Prisma.SortOrder
  benefitId?: Prisma.SortOrder
  benefitValue?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  deletedAt?: Prisma.SortOrder
}

export type membershipBenefitsSumOrderByAggregateInput = {
  id?: Prisma.SortOrder
  levelId?: Prisma.SortOrder
  benefitId?: Prisma.SortOrder
  benefitValue?: Prisma.SortOrder
}

export type membershipBenefitsCreateNestedManyWithoutLevelInput = {
  create?: Prisma.XOR<Prisma.membershipBenefitsCreateWithoutLevelInput, Prisma.membershipBenefitsUncheckedCreateWithoutLevelInput> | Prisma.membershipBenefitsCreateWithoutLevelInput[] | Prisma.membershipBenefitsUncheckedCreateWithoutLevelInput[]
  connectOrCreate?: Prisma.membershipBenefitsCreateOrConnectWithoutLevelInput | Prisma.membershipBenefitsCreateOrConnectWithoutLevelInput[]
  createMany?: Prisma.membershipBenefitsCreateManyLevelInputEnvelope
  connect?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
}

export type membershipBenefitsUncheckedCreateNestedManyWithoutLevelInput = {
  create?: Prisma.XOR<Prisma.membershipBenefitsCreateWithoutLevelInput, Prisma.membershipBenefitsUncheckedCreateWithoutLevelInput> | Prisma.membershipBenefitsCreateWithoutLevelInput[] | Prisma.membershipBenefitsUncheckedCreateWithoutLevelInput[]
  connectOrCreate?: Prisma.membershipBenefitsCreateOrConnectWithoutLevelInput | Prisma.membershipBenefitsCreateOrConnectWithoutLevelInput[]
  createMany?: Prisma.membershipBenefitsCreateManyLevelInputEnvelope
  connect?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
}

export type membershipBenefitsUpdateManyWithoutLevelNestedInput = {
  create?: Prisma.XOR<Prisma.membershipBenefitsCreateWithoutLevelInput, Prisma.membershipBenefitsUncheckedCreateWithoutLevelInput> | Prisma.membershipBenefitsCreateWithoutLevelInput[] | Prisma.membershipBenefitsUncheckedCreateWithoutLevelInput[]
  connectOrCreate?: Prisma.membershipBenefitsCreateOrConnectWithoutLevelInput | Prisma.membershipBenefitsCreateOrConnectWithoutLevelInput[]
  upsert?: Prisma.membershipBenefitsUpsertWithWhereUniqueWithoutLevelInput | Prisma.membershipBenefitsUpsertWithWhereUniqueWithoutLevelInput[]
  createMany?: Prisma.membershipBenefitsCreateManyLevelInputEnvelope
  set?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
  disconnect?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
  delete?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
  connect?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
  update?: Prisma.membershipBenefitsUpdateWithWhereUniqueWithoutLevelInput | Prisma.membershipBenefitsUpdateWithWhereUniqueWithoutLevelInput[]
  updateMany?: Prisma.membershipBenefitsUpdateManyWithWhereWithoutLevelInput | Prisma.membershipBenefitsUpdateManyWithWhereWithoutLevelInput[]
  deleteMany?: Prisma.membershipBenefitsScalarWhereInput | Prisma.membershipBenefitsScalarWhereInput[]
}

export type membershipBenefitsUncheckedUpdateManyWithoutLevelNestedInput = {
  create?: Prisma.XOR<Prisma.membershipBenefitsCreateWithoutLevelInput, Prisma.membershipBenefitsUncheckedCreateWithoutLevelInput> | Prisma.membershipBenefitsCreateWithoutLevelInput[] | Prisma.membershipBenefitsUncheckedCreateWithoutLevelInput[]
  connectOrCreate?: Prisma.membershipBenefitsCreateOrConnectWithoutLevelInput | Prisma.membershipBenefitsCreateOrConnectWithoutLevelInput[]
  upsert?: Prisma.membershipBenefitsUpsertWithWhereUniqueWithoutLevelInput | Prisma.membershipBenefitsUpsertWithWhereUniqueWithoutLevelInput[]
  createMany?: Prisma.membershipBenefitsCreateManyLevelInputEnvelope
  set?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
  disconnect?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
  delete?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
  connect?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
  update?: Prisma.membershipBenefitsUpdateWithWhereUniqueWithoutLevelInput | Prisma.membershipBenefitsUpdateWithWhereUniqueWithoutLevelInput[]
  updateMany?: Prisma.membershipBenefitsUpdateManyWithWhereWithoutLevelInput | Prisma.membershipBenefitsUpdateManyWithWhereWithoutLevelInput[]
  deleteMany?: Prisma.membershipBenefitsScalarWhereInput | Prisma.membershipBenefitsScalarWhereInput[]
}

export type membershipBenefitsCreateNestedManyWithoutBenefitInput = {
  create?: Prisma.XOR<Prisma.membershipBenefitsCreateWithoutBenefitInput, Prisma.membershipBenefitsUncheckedCreateWithoutBenefitInput> | Prisma.membershipBenefitsCreateWithoutBenefitInput[] | Prisma.membershipBenefitsUncheckedCreateWithoutBenefitInput[]
  connectOrCreate?: Prisma.membershipBenefitsCreateOrConnectWithoutBenefitInput | Prisma.membershipBenefitsCreateOrConnectWithoutBenefitInput[]
  createMany?: Prisma.membershipBenefitsCreateManyBenefitInputEnvelope
  connect?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
}

export type membershipBenefitsUncheckedCreateNestedManyWithoutBenefitInput = {
  create?: Prisma.XOR<Prisma.membershipBenefitsCreateWithoutBenefitInput, Prisma.membershipBenefitsUncheckedCreateWithoutBenefitInput> | Prisma.membershipBenefitsCreateWithoutBenefitInput[] | Prisma.membershipBenefitsUncheckedCreateWithoutBenefitInput[]
  connectOrCreate?: Prisma.membershipBenefitsCreateOrConnectWithoutBenefitInput | Prisma.membershipBenefitsCreateOrConnectWithoutBenefitInput[]
  createMany?: Prisma.membershipBenefitsCreateManyBenefitInputEnvelope
  connect?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
}

export type membershipBenefitsUpdateManyWithoutBenefitNestedInput = {
  create?: Prisma.XOR<Prisma.membershipBenefitsCreateWithoutBenefitInput, Prisma.membershipBenefitsUncheckedCreateWithoutBenefitInput> | Prisma.membershipBenefitsCreateWithoutBenefitInput[] | Prisma.membershipBenefitsUncheckedCreateWithoutBenefitInput[]
  connectOrCreate?: Prisma.membershipBenefitsCreateOrConnectWithoutBenefitInput | Prisma.membershipBenefitsCreateOrConnectWithoutBenefitInput[]
  upsert?: Prisma.membershipBenefitsUpsertWithWhereUniqueWithoutBenefitInput | Prisma.membershipBenefitsUpsertWithWhereUniqueWithoutBenefitInput[]
  createMany?: Prisma.membershipBenefitsCreateManyBenefitInputEnvelope
  set?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
  disconnect?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
  delete?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
  connect?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
  update?: Prisma.membershipBenefitsUpdateWithWhereUniqueWithoutBenefitInput | Prisma.membershipBenefitsUpdateWithWhereUniqueWithoutBenefitInput[]
  updateMany?: Prisma.membershipBenefitsUpdateManyWithWhereWithoutBenefitInput | Prisma.membershipBenefitsUpdateManyWithWhereWithoutBenefitInput[]
  deleteMany?: Prisma.membershipBenefitsScalarWhereInput | Prisma.membershipBenefitsScalarWhereInput[]
}

export type membershipBenefitsUncheckedUpdateManyWithoutBenefitNestedInput = {
  create?: Prisma.XOR<Prisma.membershipBenefitsCreateWithoutBenefitInput, Prisma.membershipBenefitsUncheckedCreateWithoutBenefitInput> | Prisma.membershipBenefitsCreateWithoutBenefitInput[] | Prisma.membershipBenefitsUncheckedCreateWithoutBenefitInput[]
  connectOrCreate?: Prisma.membershipBenefitsCreateOrConnectWithoutBenefitInput | Prisma.membershipBenefitsCreateOrConnectWithoutBenefitInput[]
  upsert?: Prisma.membershipBenefitsUpsertWithWhereUniqueWithoutBenefitInput | Prisma.membershipBenefitsUpsertWithWhereUniqueWithoutBenefitInput[]
  createMany?: Prisma.membershipBenefitsCreateManyBenefitInputEnvelope
  set?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
  disconnect?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
  delete?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
  connect?: Prisma.membershipBenefitsWhereUniqueInput | Prisma.membershipBenefitsWhereUniqueInput[]
  update?: Prisma.membershipBenefitsUpdateWithWhereUniqueWithoutBenefitInput | Prisma.membershipBenefitsUpdateWithWhereUniqueWithoutBenefitInput[]
  updateMany?: Prisma.membershipBenefitsUpdateManyWithWhereWithoutBenefitInput | Prisma.membershipBenefitsUpdateManyWithWhereWithoutBenefitInput[]
  deleteMany?: Prisma.membershipBenefitsScalarWhereInput | Prisma.membershipBenefitsScalarWhereInput[]
}

export type membershipBenefitsCreateWithoutLevelInput = {
  benefitValue: bigint | number
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  benefit: Prisma.benefitsCreateNestedOneWithoutMembershipBenefitsInput
}

export type membershipBenefitsUncheckedCreateWithoutLevelInput = {
  id?: number
  benefitId: number
  benefitValue: bigint | number
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
}

export type membershipBenefitsCreateOrConnectWithoutLevelInput = {
  where: Prisma.membershipBenefitsWhereUniqueInput
  create: Prisma.XOR<Prisma.membershipBenefitsCreateWithoutLevelInput, Prisma.membershipBenefitsUncheckedCreateWithoutLevelInput>
}

export type membershipBenefitsCreateManyLevelInputEnvelope = {
  data: Prisma.membershipBenefitsCreateManyLevelInput | Prisma.membershipBenefitsCreateManyLevelInput[]
  skipDuplicates?: boolean
}

export type membershipBenefitsUpsertWithWhereUniqueWithoutLevelInput = {
  where: Prisma.membershipBenefitsWhereUniqueInput
  update: Prisma.XOR<Prisma.membershipBenefitsUpdateWithoutLevelInput, Prisma.membershipBenefitsUncheckedUpdateWithoutLevelInput>
  create: Prisma.XOR<Prisma.membershipBenefitsCreateWithoutLevelInput, Prisma.membershipBenefitsUncheckedCreateWithoutLevelInput>
}

export type membershipBenefitsUpdateWithWhereUniqueWithoutLevelInput = {
  where: Prisma.membershipBenefitsWhereUniqueInput
  data: Prisma.XOR<Prisma.membershipBenefitsUpdateWithoutLevelInput, Prisma.membershipBenefitsUncheckedUpdateWithoutLevelInput>
}

export type membershipBenefitsUpdateManyWithWhereWithoutLevelInput = {
  where: Prisma.membershipBenefitsScalarWhereInput
  data: Prisma.XOR<Prisma.membershipBenefitsUpdateManyMutationInput, Prisma.membershipBenefitsUncheckedUpdateManyWithoutLevelInput>
}

export type membershipBenefitsScalarWhereInput = {
  AND?: Prisma.membershipBenefitsScalarWhereInput | Prisma.membershipBenefitsScalarWhereInput[]
  OR?: Prisma.membershipBenefitsScalarWhereInput[]
  NOT?: Prisma.membershipBenefitsScalarWhereInput | Prisma.membershipBenefitsScalarWhereInput[]
  id?: Prisma.IntFilter<"membershipBenefits"> | number
  levelId?: Prisma.IntFilter<"membershipBenefits"> | number
  benefitId?: Prisma.IntFilter<"membershipBenefits"> | number
  benefitValue?: Prisma.BigIntFilter<"membershipBenefits"> | bigint | number
  createdAt?: Prisma.DateTimeFilter<"membershipBenefits"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"membershipBenefits"> | Date | string
  deletedAt?: Prisma.DateTimeNullableFilter<"membershipBenefits"> | Date | string | null
}

export type membershipBenefitsCreateWithoutBenefitInput = {
  benefitValue: bigint | number
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
  level: Prisma.membershipLevelsCreateNestedOneWithoutMembershipBenefitsInput
}

export type membershipBenefitsUncheckedCreateWithoutBenefitInput = {
  id?: number
  levelId: number
  benefitValue: bigint | number
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
}

export type membershipBenefitsCreateOrConnectWithoutBenefitInput = {
  where: Prisma.membershipBenefitsWhereUniqueInput
  create: Prisma.XOR<Prisma.membershipBenefitsCreateWithoutBenefitInput, Prisma.membershipBenefitsUncheckedCreateWithoutBenefitInput>
}

export type membershipBenefitsCreateManyBenefitInputEnvelope = {
  data: Prisma.membershipBenefitsCreateManyBenefitInput | Prisma.membershipBenefitsCreateManyBenefitInput[]
  skipDuplicates?: boolean
}

export type membershipBenefitsUpsertWithWhereUniqueWithoutBenefitInput = {
  where: Prisma.membershipBenefitsWhereUniqueInput
  update: Prisma.XOR<Prisma.membershipBenefitsUpdateWithoutBenefitInput, Prisma.membershipBenefitsUncheckedUpdateWithoutBenefitInput>
  create: Prisma.XOR<Prisma.membershipBenefitsCreateWithoutBenefitInput, Prisma.membershipBenefitsUncheckedCreateWithoutBenefitInput>
}

export type membershipBenefitsUpdateWithWhereUniqueWithoutBenefitInput = {
  where: Prisma.membershipBenefitsWhereUniqueInput
  data: Prisma.XOR<Prisma.membershipBenefitsUpdateWithoutBenefitInput, Prisma.membershipBenefitsUncheckedUpdateWithoutBenefitInput>
}

export type membershipBenefitsUpdateManyWithWhereWithoutBenefitInput = {
  where: Prisma.membershipBenefitsScalarWhereInput
  data: Prisma.XOR<Prisma.membershipBenefitsUpdateManyMutationInput, Prisma.membershipBenefitsUncheckedUpdateManyWithoutBenefitInput>
}

export type membershipBenefitsCreateManyLevelInput = {
  id?: number
  benefitId: number
  benefitValue: bigint | number
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
}

export type membershipBenefitsUpdateWithoutLevelInput = {
  benefitValue?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  deletedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  benefit?: Prisma.benefitsUpdateOneRequiredWithoutMembershipBenefitsNestedInput
}

export type membershipBenefitsUncheckedUpdateWithoutLevelInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  benefitId?: Prisma.IntFieldUpdateOperationsInput | number
  benefitValue?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  deletedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type membershipBenefitsUncheckedUpdateManyWithoutLevelInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  benefitId?: Prisma.IntFieldUpdateOperationsInput | number
  benefitValue?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  deletedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type membershipBenefitsCreateManyBenefitInput = {
  id?: number
  levelId: number
  benefitValue: bigint | number
  createdAt?: Date | string
  updatedAt?: Date | string
  deletedAt?: Date | string | null
}

export type membershipBenefitsUpdateWithoutBenefitInput = {
  benefitValue?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  deletedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  level?: Prisma.membershipLevelsUpdateOneRequiredWithoutMembershipBenefitsNestedInput
}

export type membershipBenefitsUncheckedUpdateWithoutBenefitInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  levelId?: Prisma.IntFieldUpdateOperationsInput | number
  benefitValue?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  deletedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}

export type membershipBenefitsUncheckedUpdateManyWithoutBenefitInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  levelId?: Prisma.IntFieldUpdateOperationsInput | number
  benefitValue?: Prisma.BigIntFieldUpdateOperationsInput | bigint | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  deletedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
}



export type membershipBenefitsSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  levelId?: boolean
  benefitId?: boolean
  benefitValue?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
  level?: boolean | Prisma.membershipLevelsDefaultArgs<ExtArgs>
  benefit?: boolean | Prisma.benefitsDefaultArgs<ExtArgs>
}, ExtArgs["result"]["membershipBenefits"]>

export type membershipBenefitsSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  levelId?: boolean
  benefitId?: boolean
  benefitValue?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
  level?: boolean | Prisma.membershipLevelsDefaultArgs<ExtArgs>
  benefit?: boolean | Prisma.benefitsDefaultArgs<ExtArgs>
}, ExtArgs["result"]["membershipBenefits"]>

export type membershipBenefitsSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  levelId?: boolean
  benefitId?: boolean
  benefitValue?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
  level?: boolean | Prisma.membershipLevelsDefaultArgs<ExtArgs>
  benefit?: boolean | Prisma.benefitsDefaultArgs<ExtArgs>
}, ExtArgs["result"]["membershipBenefits"]>

export type membershipBenefitsSelectScalar = {
  id?: boolean
  levelId?: boolean
  benefitId?: boolean
  benefitValue?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  deletedAt?: boolean
}

export type membershipBenefitsOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "levelId" | "benefitId" | "benefitValue" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["membershipBenefits"]>
export type membershipBenefitsInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  level?: boolean | Prisma.membershipLevelsDefaultArgs<ExtArgs>
  benefit?: boolean | Prisma.benefitsDefaultArgs<ExtArgs>
}
export type membershipBenefitsIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  level?: boolean | Prisma.membershipLevelsDefaultArgs<ExtArgs>
  benefit?: boolean | Prisma.benefitsDefaultArgs<ExtArgs>
}
export type membershipBenefitsIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  level?: boolean | Prisma.membershipLevelsDefaultArgs<ExtArgs>
  benefit?: boolean | Prisma.benefitsDefaultArgs<ExtArgs>
}

export type $membershipBenefitsPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "membershipBenefits"
  objects: {
    /**
     * ÂÖ≥ËÅîÁöÑ‰ºöÂëòÁ∫ßÂà´
     */
    level: Prisma.$membershipLevelsPayload<ExtArgs>
    /**
     * ÂÖ≥ËÅîÁöÑÊùÉÁõä
     */
    benefit: Prisma.$benefitsPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    /**
     * ‰ºöÂëòÊùÉÁõäÂÖ≥ËÅîIDÔºå‰∏ªÈîÆÔºåËá™Â¢û
     */
    id: number
    /**
     * ‰ºöÂëòÁ∫ßÂà´ID
     */
    levelId: number
    /**
     * ÊùÉÁõäID
     */
    benefitId: number
    /**
     * ÊùÉÁõäÂÄº
     */
    benefitValue: bigint
    /**
     * ÂàõÂª∫Êó∂Èó¥
     */
    createdAt: Date
    /**
     * ÊúÄÂêéÊõ¥Êñ∞Êó∂Èó¥
     */
    updatedAt: Date
    /**
     * Âà†Èô§Êó∂Èó¥Ôºå‰∏∫NULLË°®Á§∫Êú™Âà†Èô§
     */
    deletedAt: Date | null
  }, ExtArgs["result"]["membershipBenefits"]>
  composites: {}
}

export type membershipBenefitsGetPayload<S extends boolean | null | undefined | membershipBenefitsDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$membershipBenefitsPayload, S>

export type membershipBenefitsCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<membershipBenefitsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: MembershipBenefitsCountAggregateInputType | true
  }

export interface membershipBenefitsDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['membershipBenefits'], meta: { name: 'membershipBenefits' } }
  /**
   * Find zero or one MembershipBenefits that matches the filter.
   * @param {membershipBenefitsFindUniqueArgs} args - Arguments to find a MembershipBenefits
   * @example
   * // Get one MembershipBenefits
   * const membershipBenefits = await prisma.membershipBenefits.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends membershipBenefitsFindUniqueArgs>(args: Prisma.SelectSubset<T, membershipBenefitsFindUniqueArgs<ExtArgs>>): Prisma.Prisma__membershipBenefitsClient<runtime.Types.Result.GetResult<Prisma.$membershipBenefitsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one MembershipBenefits that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {membershipBenefitsFindUniqueOrThrowArgs} args - Arguments to find a MembershipBenefits
   * @example
   * // Get one MembershipBenefits
   * const membershipBenefits = await prisma.membershipBenefits.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends membershipBenefitsFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, membershipBenefitsFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__membershipBenefitsClient<runtime.Types.Result.GetResult<Prisma.$membershipBenefitsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first MembershipBenefits that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {membershipBenefitsFindFirstArgs} args - Arguments to find a MembershipBenefits
   * @example
   * // Get one MembershipBenefits
   * const membershipBenefits = await prisma.membershipBenefits.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends membershipBenefitsFindFirstArgs>(args?: Prisma.SelectSubset<T, membershipBenefitsFindFirstArgs<ExtArgs>>): Prisma.Prisma__membershipBenefitsClient<runtime.Types.Result.GetResult<Prisma.$membershipBenefitsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first MembershipBenefits that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {membershipBenefitsFindFirstOrThrowArgs} args - Arguments to find a MembershipBenefits
   * @example
   * // Get one MembershipBenefits
   * const membershipBenefits = await prisma.membershipBenefits.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends membershipBenefitsFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, membershipBenefitsFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__membershipBenefitsClient<runtime.Types.Result.GetResult<Prisma.$membershipBenefitsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more MembershipBenefits that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {membershipBenefitsFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all MembershipBenefits
   * const membershipBenefits = await prisma.membershipBenefits.findMany()
   * 
   * // Get first 10 MembershipBenefits
   * const membershipBenefits = await prisma.membershipBenefits.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const membershipBenefitsWithIdOnly = await prisma.membershipBenefits.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends membershipBenefitsFindManyArgs>(args?: Prisma.SelectSubset<T, membershipBenefitsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$membershipBenefitsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a MembershipBenefits.
   * @param {membershipBenefitsCreateArgs} args - Arguments to create a MembershipBenefits.
   * @example
   * // Create one MembershipBenefits
   * const MembershipBenefits = await prisma.membershipBenefits.create({
   *   data: {
   *     // ... data to create a MembershipBenefits
   *   }
   * })
   * 
   */
  create<T extends membershipBenefitsCreateArgs>(args: Prisma.SelectSubset<T, membershipBenefitsCreateArgs<ExtArgs>>): Prisma.Prisma__membershipBenefitsClient<runtime.Types.Result.GetResult<Prisma.$membershipBenefitsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many MembershipBenefits.
   * @param {membershipBenefitsCreateManyArgs} args - Arguments to create many MembershipBenefits.
   * @example
   * // Create many MembershipBenefits
   * const membershipBenefits = await prisma.membershipBenefits.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends membershipBenefitsCreateManyArgs>(args?: Prisma.SelectSubset<T, membershipBenefitsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many MembershipBenefits and returns the data saved in the database.
   * @param {membershipBenefitsCreateManyAndReturnArgs} args - Arguments to create many MembershipBenefits.
   * @example
   * // Create many MembershipBenefits
   * const membershipBenefits = await prisma.membershipBenefits.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many MembershipBenefits and only return the `id`
   * const membershipBenefitsWithIdOnly = await prisma.membershipBenefits.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends membershipBenefitsCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, membershipBenefitsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$membershipBenefitsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a MembershipBenefits.
   * @param {membershipBenefitsDeleteArgs} args - Arguments to delete one MembershipBenefits.
   * @example
   * // Delete one MembershipBenefits
   * const MembershipBenefits = await prisma.membershipBenefits.delete({
   *   where: {
   *     // ... filter to delete one MembershipBenefits
   *   }
   * })
   * 
   */
  delete<T extends membershipBenefitsDeleteArgs>(args: Prisma.SelectSubset<T, membershipBenefitsDeleteArgs<ExtArgs>>): Prisma.Prisma__membershipBenefitsClient<runtime.Types.Result.GetResult<Prisma.$membershipBenefitsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one MembershipBenefits.
   * @param {membershipBenefitsUpdateArgs} args - Arguments to update one MembershipBenefits.
   * @example
   * // Update one MembershipBenefits
   * const membershipBenefits = await prisma.membershipBenefits.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends membershipBenefitsUpdateArgs>(args: Prisma.SelectSubset<T, membershipBenefitsUpdateArgs<ExtArgs>>): Prisma.Prisma__membershipBenefitsClient<runtime.Types.Result.GetResult<Prisma.$membershipBenefitsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more MembershipBenefits.
   * @param {membershipBenefitsDeleteManyArgs} args - Arguments to filter MembershipBenefits to delete.
   * @example
   * // Delete a few MembershipBenefits
   * const { count } = await prisma.membershipBenefits.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends membershipBenefitsDeleteManyArgs>(args?: Prisma.SelectSubset<T, membershipBenefitsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more MembershipBenefits.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {membershipBenefitsUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many MembershipBenefits
   * const membershipBenefits = await prisma.membershipBenefits.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends membershipBenefitsUpdateManyArgs>(args: Prisma.SelectSubset<T, membershipBenefitsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more MembershipBenefits and returns the data updated in the database.
   * @param {membershipBenefitsUpdateManyAndReturnArgs} args - Arguments to update many MembershipBenefits.
   * @example
   * // Update many MembershipBenefits
   * const membershipBenefits = await prisma.membershipBenefits.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more MembershipBenefits and only return the `id`
   * const membershipBenefitsWithIdOnly = await prisma.membershipBenefits.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends membershipBenefitsUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, membershipBenefitsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$membershipBenefitsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one MembershipBenefits.
   * @param {membershipBenefitsUpsertArgs} args - Arguments to update or create a MembershipBenefits.
   * @example
   * // Update or create a MembershipBenefits
   * const membershipBenefits = await prisma.membershipBenefits.upsert({
   *   create: {
   *     // ... data to create a MembershipBenefits
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the MembershipBenefits we want to update
   *   }
   * })
   */
  upsert<T extends membershipBenefitsUpsertArgs>(args: Prisma.SelectSubset<T, membershipBenefitsUpsertArgs<ExtArgs>>): Prisma.Prisma__membershipBenefitsClient<runtime.Types.Result.GetResult<Prisma.$membershipBenefitsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of MembershipBenefits.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {membershipBenefitsCountArgs} args - Arguments to filter MembershipBenefits to count.
   * @example
   * // Count the number of MembershipBenefits
   * const count = await prisma.membershipBenefits.count({
   *   where: {
   *     // ... the filter for the MembershipBenefits we want to count
   *   }
   * })
  **/
  count<T extends membershipBenefitsCountArgs>(
    args?: Prisma.Subset<T, membershipBenefitsCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], MembershipBenefitsCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a MembershipBenefits.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MembershipBenefitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends MembershipBenefitsAggregateArgs>(args: Prisma.Subset<T, MembershipBenefitsAggregateArgs>): Prisma.PrismaPromise<GetMembershipBenefitsAggregateType<T>>

  /**
   * Group by MembershipBenefits.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {membershipBenefitsGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends membershipBenefitsGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: membershipBenefitsGroupByArgs['orderBy'] }
      : { orderBy?: membershipBenefitsGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, membershipBenefitsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembershipBenefitsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the membershipBenefits model
 */
readonly fields: membershipBenefitsFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for membershipBenefits.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__membershipBenefitsClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  level<T extends Prisma.membershipLevelsDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.membershipLevelsDefaultArgs<ExtArgs>>): Prisma.Prisma__membershipLevelsClient<runtime.Types.Result.GetResult<Prisma.$membershipLevelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  benefit<T extends Prisma.benefitsDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.benefitsDefaultArgs<ExtArgs>>): Prisma.Prisma__benefitsClient<runtime.Types.Result.GetResult<Prisma.$benefitsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the membershipBenefits model
 */
export interface membershipBenefitsFieldRefs {
  readonly id: Prisma.FieldRef<"membershipBenefits", 'Int'>
  readonly levelId: Prisma.FieldRef<"membershipBenefits", 'Int'>
  readonly benefitId: Prisma.FieldRef<"membershipBenefits", 'Int'>
  readonly benefitValue: Prisma.FieldRef<"membershipBenefits", 'BigInt'>
  readonly createdAt: Prisma.FieldRef<"membershipBenefits", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"membershipBenefits", 'DateTime'>
  readonly deletedAt: Prisma.FieldRef<"membershipBenefits", 'DateTime'>
}
    

// Custom InputTypes
/**
 * membershipBenefits findUnique
 */
export type membershipBenefitsFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the membershipBenefits
   */
  select?: Prisma.membershipBenefitsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the membershipBenefits
   */
  omit?: Prisma.membershipBenefitsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.membershipBenefitsInclude<ExtArgs> | null
  /**
   * Filter, which membershipBenefits to fetch.
   */
  where: Prisma.membershipBenefitsWhereUniqueInput
}

/**
 * membershipBenefits findUniqueOrThrow
 */
export type membershipBenefitsFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the membershipBenefits
   */
  select?: Prisma.membershipBenefitsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the membershipBenefits
   */
  omit?: Prisma.membershipBenefitsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.membershipBenefitsInclude<ExtArgs> | null
  /**
   * Filter, which membershipBenefits to fetch.
   */
  where: Prisma.membershipBenefitsWhereUniqueInput
}

/**
 * membershipBenefits findFirst
 */
export type membershipBenefitsFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the membershipBenefits
   */
  select?: Prisma.membershipBenefitsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the membershipBenefits
   */
  omit?: Prisma.membershipBenefitsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.membershipBenefitsInclude<ExtArgs> | null
  /**
   * Filter, which membershipBenefits to fetch.
   */
  where?: Prisma.membershipBenefitsWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of membershipBenefits to fetch.
   */
  orderBy?: Prisma.membershipBenefitsOrderByWithRelationInput | Prisma.membershipBenefitsOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for membershipBenefits.
   */
  cursor?: Prisma.membershipBenefitsWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `¬±n` membershipBenefits from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` membershipBenefits.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of membershipBenefits.
   */
  distinct?: Prisma.MembershipBenefitsScalarFieldEnum | Prisma.MembershipBenefitsScalarFieldEnum[]
}

/**
 * membershipBenefits findFirstOrThrow
 */
export type membershipBenefitsFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the membershipBenefits
   */
  select?: Prisma.membershipBenefitsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the membershipBenefits
   */
  omit?: Prisma.membershipBenefitsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.membershipBenefitsInclude<ExtArgs> | null
  /**
   * Filter, which membershipBenefits to fetch.
   */
  where?: Prisma.membershipBenefitsWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of membershipBenefits to fetch.
   */
  orderBy?: Prisma.membershipBenefitsOrderByWithRelationInput | Prisma.membershipBenefitsOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for membershipBenefits.
   */
  cursor?: Prisma.membershipBenefitsWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `¬±n` membershipBenefits from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` membershipBenefits.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of membershipBenefits.
   */
  distinct?: Prisma.MembershipBenefitsScalarFieldEnum | Prisma.MembershipBenefitsScalarFieldEnum[]
}

/**
 * membershipBenefits findMany
 */
export type membershipBenefitsFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the membershipBenefits
   */
  select?: Prisma.membershipBenefitsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the membershipBenefits
   */
  omit?: Prisma.membershipBenefitsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.membershipBenefitsInclude<ExtArgs> | null
  /**
   * Filter, which membershipBenefits to fetch.
   */
  where?: Prisma.membershipBenefitsWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of membershipBenefits to fetch.
   */
  orderBy?: Prisma.membershipBenefitsOrderByWithRelationInput | Prisma.membershipBenefitsOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing membershipBenefits.
   */
  cursor?: Prisma.membershipBenefitsWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `¬±n` membershipBenefits from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` membershipBenefits.
   */
  skip?: number
  distinct?: Prisma.MembershipBenefitsScalarFieldEnum | Prisma.MembershipBenefitsScalarFieldEnum[]
}

/**
 * membershipBenefits create
 */
export type membershipBenefitsCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the membershipBenefits
   */
  select?: Prisma.membershipBenefitsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the membershipBenefits
   */
  omit?: Prisma.membershipBenefitsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.membershipBenefitsInclude<ExtArgs> | null
  /**
   * The data needed to create a membershipBenefits.
   */
  data: Prisma.XOR<Prisma.membershipBenefitsCreateInput, Prisma.membershipBenefitsUncheckedCreateInput>
}

/**
 * membershipBenefits createMany
 */
export type membershipBenefitsCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many membershipBenefits.
   */
  data: Prisma.membershipBenefitsCreateManyInput | Prisma.membershipBenefitsCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * membershipBenefits createManyAndReturn
 */
export type membershipBenefitsCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the membershipBenefits
   */
  select?: Prisma.membershipBenefitsSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the membershipBenefits
   */
  omit?: Prisma.membershipBenefitsOmit<ExtArgs> | null
  /**
   * The data used to create many membershipBenefits.
   */
  data: Prisma.membershipBenefitsCreateManyInput | Prisma.membershipBenefitsCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.membershipBenefitsIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * membershipBenefits update
 */
export type membershipBenefitsUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the membershipBenefits
   */
  select?: Prisma.membershipBenefitsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the membershipBenefits
   */
  omit?: Prisma.membershipBenefitsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.membershipBenefitsInclude<ExtArgs> | null
  /**
   * The data needed to update a membershipBenefits.
   */
  data: Prisma.XOR<Prisma.membershipBenefitsUpdateInput, Prisma.membershipBenefitsUncheckedUpdateInput>
  /**
   * Choose, which membershipBenefits to update.
   */
  where: Prisma.membershipBenefitsWhereUniqueInput
}

/**
 * membershipBenefits updateMany
 */
export type membershipBenefitsUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update membershipBenefits.
   */
  data: Prisma.XOR<Prisma.membershipBenefitsUpdateManyMutationInput, Prisma.membershipBenefitsUncheckedUpdateManyInput>
  /**
   * Filter which membershipBenefits to update
   */
  where?: Prisma.membershipBenefitsWhereInput
  /**
   * Limit how many membershipBenefits to update.
   */
  limit?: number
}

/**
 * membershipBenefits updateManyAndReturn
 */
export type membershipBenefitsUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the membershipBenefits
   */
  select?: Prisma.membershipBenefitsSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the membershipBenefits
   */
  omit?: Prisma.membershipBenefitsOmit<ExtArgs> | null
  /**
   * The data used to update membershipBenefits.
   */
  data: Prisma.XOR<Prisma.membershipBenefitsUpdateManyMutationInput, Prisma.membershipBenefitsUncheckedUpdateManyInput>
  /**
   * Filter which membershipBenefits to update
   */
  where?: Prisma.membershipBenefitsWhereInput
  /**
   * Limit how many membershipBenefits to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.membershipBenefitsIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * membershipBenefits upsert
 */
export type membershipBenefitsUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the membershipBenefits
   */
  select?: Prisma.membershipBenefitsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the membershipBenefits
   */
  omit?: Prisma.membershipBenefitsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.membershipBenefitsInclude<ExtArgs> | null
  /**
   * The filter to search for the membershipBenefits to update in case it exists.
   */
  where: Prisma.membershipBenefitsWhereUniqueInput
  /**
   * In case the membershipBenefits found by the `where` argument doesn't exist, create a new membershipBenefits with this data.
   */
  create: Prisma.XOR<Prisma.membershipBenefitsCreateInput, Prisma.membershipBenefitsUncheckedCreateInput>
  /**
   * In case the membershipBenefits was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.membershipBenefitsUpdateInput, Prisma.membershipBenefitsUncheckedUpdateInput>
}

/**
 * membershipBenefits delete
 */
export type membershipBenefitsDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the membershipBenefits
   */
  select?: Prisma.membershipBenefitsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the membershipBenefits
   */
  omit?: Prisma.membershipBenefitsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.membershipBenefitsInclude<ExtArgs> | null
  /**
   * Filter which membershipBenefits to delete.
   */
  where: Prisma.membershipBenefitsWhereUniqueInput
}

/**
 * membershipBenefits deleteMany
 */
export type membershipBenefitsDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which membershipBenefits to delete
   */
  where?: Prisma.membershipBenefitsWhereInput
  /**
   * Limit how many membershipBenefits to delete.
   */
  limit?: number
}

/**
 * membershipBenefits without action
 */
export type membershipBenefitsDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the membershipBenefits
   */
  select?: Prisma.membershipBenefitsSelect<ExtArgs> | null
  /**
   * Omit specific fields from the membershipBenefits
   */
  omit?: Prisma.membershipBenefitsOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.membershipBenefitsInclude<ExtArgs> | null
}
